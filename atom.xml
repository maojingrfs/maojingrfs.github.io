<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mao Jing</title>
  
  <subtitle>匮乏即是富足，自律产生喜悦！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-24T10:12:52.645Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mao Jing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shiro-身份验证</title>
    <link href="http://yoursite.com/2019/01/24/Shiro-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2019/01/24/Shiro-身份验证/</id>
    <published>2019-01-24T07:23:32.000Z</published>
    <updated>2019-01-24T10:12:52.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shiro身份验证涉及两个重要概念，principals和credentials。最常见的principals和credentials是用户名和密码，另外还有Subject和Realm。下面通过实际例子说明。</p><a id="more"></a><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.这里使用Spring Boot 2.1.2创建一个web项目，构建中我是勾选了<code>web</code>和<code>SQL</code>-&gt;<code>MySql</code>。</p><p>2.我的pom.xml文件中的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>3.测试中需要在<code>resources</code>-&gt;<code>static</code>文件夹下创建<code>html</code>文件，所以<code>application.properties</code>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.suffix=.html</span><br></pre></td></tr></table></figure><h2 id="textRealm测试"><a href="#textRealm测试" class="headerlink" title="textRealm测试"></a>textRealm测试</h2><h3 id="1-在static路径下创建login-html文件："><a href="#1-在static路径下创建login-html文件：" class="headerlink" title="1.在static路径下创建login.html文件："></a>1.在<code>static</code>路径下创建<code>login.html</code>文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form name=&quot;login&quot; action=&quot;/login&quot; method=&quot;post&quot; onsubmit=&quot;return beforeSubmit()&quot;&gt;</span><br><span class="line">        用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;/&gt; &lt;br/&gt;</span><br><span class="line">        密  码：&lt;input type=&quot;password&quot; id=&quot;password&quot;  name=&quot;password&quot;/&gt; &lt;br/&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;submit&quot;/&gt; &lt;br/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function beforeSubmit() &#123;</span><br><span class="line">            var username = document.getElementById(&apos;username&apos;).value;</span><br><span class="line">            var password = document.getElementById(&apos;password&apos;).value;</span><br><span class="line">            if (username.length &lt; 3 || password.length &lt; 3) &#123;</span><br><span class="line">                alert(&apos;格式不正确！&apos;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在<code>static</code>路径下创建<code>fail.html</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;失败啦！&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在<code>static</code>路径下创建<code>success.html</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;成功！&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="2-在resources路径下创建textShiro-ini文件（IDEA会提示安装插件，安装重启即可），配置如下："><a href="#2-在resources路径下创建textShiro-ini文件（IDEA会提示安装插件，安装重启即可），配置如下：" class="headerlink" title="2.在resources路径下创建textShiro.ini文件（IDEA会提示安装插件，安装重启即可），配置如下："></a>2.在<code>resources</code>路径下创建<code>textShiro.ini</code>文件（IDEA会提示安装插件，安装重启即可），配置如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">maojing=123</span><br><span class="line">yihe=123</span><br></pre></td></tr></table></figure><h3 id="3-创建控制器LoginController-如下："><a href="#3-创建控制器LoginController-如下：" class="headerlink" title="3.创建控制器LoginController,如下："></a>3.创建控制器<code>LoginController</code>,如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationException;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.config.IniSecurityManagerFactory;</span><br><span class="line">import org.apache.shiro.mgt.SecurityManager;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.apache.shiro.util.Factory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">    @RequestMapping(value = &quot;&quot;,method = RequestMethod.GET)</span><br><span class="line">    public String sayHi()&#123;</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(value = &quot;login&quot;,method = RequestMethod.GET)</span><br><span class="line">    public String login(HttpServletRequest req)&#123;</span><br><span class="line">//获取表单用户信息</span><br><span class="line">        String username = req.getParameter(&quot;username&quot;);</span><br><span class="line">        String password = req.getParameter(&quot;password&quot;);</span><br><span class="line">        </span><br><span class="line">//使用Ini配置文件初始化SecurityManager</span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:textShiro.ini&quot;);</span><br><span class="line">        </span><br><span class="line">        //得到SecurityManager实例 并绑定给SecurityUtils</span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        </span><br><span class="line">        //得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</span><br><span class="line">        Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">        try&#123;</span><br><span class="line">            currentUser.login(token);</span><br><span class="line">            System.out.println(&quot;身份认证成功！&quot;);</span><br><span class="line">        &#125;catch(AuthenticationException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;身份认证失败！&quot;);</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        currentUser.logout();</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.收集用户身份/凭证，即如用户名/密码；</span><br><span class="line"></span><br><span class="line">2、调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；</span><br><span class="line"></span><br><span class="line">3、最后调用Subject.logout进行退出操作</span><br></pre></td></tr></table></figure><h2 id="jdbcRealm测试"><a href="#jdbcRealm测试" class="headerlink" title="jdbcRealm测试"></a>jdbcRealm测试</h2><p>将上面的<code>textRealm</code>测试跑通，并理解的前提下，再切换到<code>jdbcRealm</code>便好理解多了。</p><h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h3><p>创建一个<code>shiro</code>数据库，并创建一个名为<code>users</code>的表。如下图：</p><img src="/2019/01/24/Shiro-身份验证/image1.jpg"><h3 id="2-shiro-jdbc-realm1-ini"><a href="#2-shiro-jdbc-realm1-ini" class="headerlink" title="2.shiro-jdbc-realm1.ini"></a>2.<code>shiro-jdbc-realm1.ini</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure><h3 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h3><p>将上面<code>LoginController</code>里面的 配置文件路径修改为：<code>shiro-jdbc-realm1.ini</code>即可测试。</p><h2 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h2><h3 id="1-数据库-1"><a href="#1-数据库-1" class="headerlink" title="1.数据库"></a>1.数据库</h3><p>沿用<code>shiro</code>数据库即可。</p><h3 id="2-shiro-my-realm1-ini"><a href="#2-shiro-my-realm1-ini" class="headerlink" title="2.shiro-my-realm1.ini"></a>2.<code>shiro-my-realm1.ini</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 声明realm</span><br><span class="line">myRealm1= com.mj.test.shiro.realm.MyRealm1</span><br><span class="line"># 指定securityManager的realms实现</span><br><span class="line">securityManager.realms=$myRealm1</span><br></pre></td></tr></table></figure><h3 id="3-自定义Realm"><a href="#3-自定义Realm" class="headerlink" title="3.自定义Realm"></a>3.自定义Realm</h3><p>创建一个<code>MyRealm1</code>类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.realm.Realm;</span><br><span class="line">public class MyRealm1 implements Realm &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;myrealm1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</span><br><span class="line">        //仅支持UsernamePasswordToken类型的Token</span><br><span class="line">        return authenticationToken instanceof UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">        //获取身份principal</span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        //获取凭证credential</span><br><span class="line">        String password = new String((char[])authenticationToken.getCredentials());</span><br><span class="line">        if (!&quot;maojing&quot;.equals(username))&#123;</span><br><span class="line">            //用户名错误</span><br><span class="line">            throw new UnknownAccountException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!&quot;123&quot;.equals(password))&#123;</span><br><span class="line">            //密码错误</span><br><span class="line">            throw new IncorrectCredentialsException();</span><br><span class="line">        &#125;</span><br><span class="line">        //验证成功，放回AuthenticationInfo</span><br><span class="line">        return new SimpleAuthenticationInfo(username,password,getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-修改"><a href="#4-修改" class="headerlink" title="4.修改"></a>4.修改</h3><p>继续沿用上面创建的<code>LoginController</code>，修改配置文件路径修改为：<code>shiro-my-realm1.ini</code>即可测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Shiro身份验证涉及两个重要概念，principals和credentials。最常见的principals和credentials是用户名和密码，另外还有Subject和Realm。下面通过实际例子说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Shiro" scheme="http://yoursite.com/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://yoursite.com/tags/Shiro/"/>
    
      <category term="身份验证" scheme="http://yoursite.com/tags/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Shiro-简介</title>
    <link href="http://yoursite.com/2019/01/23/Shiro-%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/01/23/Shiro-简介/</id>
    <published>2019-01-23T11:20:48.000Z</published>
    <updated>2019-01-23T11:51:46.622Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/23/Shiro-简介/image0.jpg"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Apache Shiro是java的一个安全框架。相较于Spring Security的复杂强大，Shiro显得更加小巧简单，至于二者说更好，这个没有一个标准答案，能切合实际的解决项目问题就是最好的。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Shiro可以非常容易满足应用开发需求，既可运行在JavaSE环境，也可运行在JavaEE环境。Shiro主要帮我们完成：认证、授权、加密、会话管理、与Web集成、缓存等功能（大多时候这已经足够用了）。同时Shiro的API也是非常简单。</p><h2 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h2><p>再看下面图解时，我们要先有：用户，角色，权限这三个概念。</p><p>功能点如图：</p><img src="/2019/01/23/Shiro-简介/image1.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1.Authentication：身份认证/登录。验证用户是不是拥有相应的身份；</span><br><span class="line"></span><br><span class="line">2.Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</span><br><span class="line"></span><br><span class="line">3.Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</span><br><span class="line"></span><br><span class="line">4.Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</span><br><span class="line"></span><br><span class="line">5.Web Support：Web支持，可以非常容易的集成到Web环境；</span><br><span class="line"></span><br><span class="line">6.Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</span><br><span class="line"></span><br><span class="line">7.Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</span><br><span class="line"></span><br><span class="line">8.Testing：提供测试支持；</span><br><span class="line"></span><br><span class="line">9.Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</span><br><span class="line"></span><br><span class="line">10.Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</span><br><span class="line"></span><br><span class="line">11.Shiro不会去维护用户和权限，这些需要我们自己设计实现，再通过相应的接口注入给shiro。</span><br></pre></td></tr></table></figure><h2 id="工作图"><a href="#工作图" class="headerlink" title="工作图"></a>工作图</h2><p>从应用程序角度来观察如何使用Shiro完成工作，如下图：</p><img src="/2019/01/23/Shiro-简介/image2.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">1.Subject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；</span><br><span class="line"></span><br><span class="line">2.SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</span><br><span class="line"></span><br><span class="line">3.Realm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</span><br></pre></td></tr></table></figure><p>简单来说：应用通过Subject来进行认证授权，Subject又委托给SecurityManager，这时需要我们给SecurityManager注入Realm,来保证SecurityManager能得到合法的用户及其权限进行判断。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>接下来从内部来看看Shiro的架构设计，如下图：</p><img src="/2019/01/23/Shiro-简介/image3.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">1.Subject：主体，可以看到主体可以是任何可以与应用交互的“用户”；</span><br><span class="line"></span><br><span class="line">2.SecurityManager：相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。</span><br><span class="line"></span><br><span class="line">3.Authenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</span><br><span class="line"></span><br><span class="line">4.Authrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</span><br><span class="line"></span><br><span class="line">5.Realm：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；</span><br><span class="line"></span><br><span class="line">6.SessionManager：如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；</span><br><span class="line"></span><br><span class="line">7.SessionDAO：DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；</span><br><span class="line"></span><br><span class="line">8.CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</span><br><span class="line"></span><br><span class="line">9.Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://shiro.apache.org/reference.html" target="_blank" rel="noopener">http://shiro.apache.org/reference.html</a></p><p><a href="https://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/2018936</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/23/Shiro-简介/image0.jpg&quot;&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Apache Shiro是java的一个安全框架。相较于Spring Security的复杂强大，Shiro显得更加小巧简单，至于二者说更好，这个没有一个标准答案，能切合实际的解决项目问题就是最好的。&lt;/p&gt;
    
    </summary>
    
      <category term="Shiro" scheme="http://yoursite.com/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://yoursite.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>权限管理-‘栗’子</title>
    <link href="http://yoursite.com/2019/01/23/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-%E2%80%98%E6%A0%97%E2%80%99%E5%AD%90/"/>
    <id>http://yoursite.com/2019/01/23/权限管理-‘栗’子/</id>
    <published>2019-01-23T08:10:15.000Z</published>
    <updated>2019-01-23T09:31:59.859Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/23/权限管理-‘栗’子/image1.jpg"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>权限管理MySql数据库设计，看下这里吧！</p><a id="more"></a><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>假定我们的权限系统设计需求是这样，角色有：读者，作者以及管理员；操作权限有：收藏（celloction），写小说（write ），发布小说（distribution）。其中读者有收藏小说权限，作者有写小说权限，而管理员有发布小说的权限。</p><h1 id="数据库及表设计如下"><a href="#数据库及表设计如下" class="headerlink" title="数据库及表设计如下"></a>数据库及表设计如下</h1><h2 id="t-user"><a href="#t-user" class="headerlink" title="t_user"></a>t_user</h2><p>如下图：</p><img src="/2019/01/23/权限管理-‘栗’子/image2.jpg"><p>填充测试数据：</p><img src="/2019/01/23/权限管理-‘栗’子/image22.jpg"><h2 id="t-role"><a href="#t-role" class="headerlink" title="t_role"></a>t_role</h2><p>如下图：</p><img src="/2019/01/23/权限管理-‘栗’子/image3.jpg"><p>填充测试数据：</p><h2 id="t-authority"><a href="#t-authority" class="headerlink" title="t_authority"></a>t_authority</h2><p>如下图：</p><img src="/2019/01/23/权限管理-‘栗’子/image4.jpg"><p>填充测试数据：</p><img src="/2019/01/23/权限管理-‘栗’子/image44.jpg"><h2 id="user-role"><a href="#user-role" class="headerlink" title="user_role"></a>user_role</h2><p>如下图：</p><img src="/2019/01/23/权限管理-‘栗’子/image5.jpg"><p>外键设置：</p><img src="/2019/01/23/权限管理-‘栗’子/image55.jpg"><p>填充测试数据：</p><img src="/2019/01/23/权限管理-‘栗’子/image555.jpg"><h2 id="role-authority"><a href="#role-authority" class="headerlink" title="role_authority"></a>role_authority</h2><p>如下图：</p><img src="/2019/01/23/权限管理-‘栗’子/image6.jpg"><p>外键设置：</p><img src="/2019/01/23/权限管理-‘栗’子/image66.jpg"><p>填充测试数据：</p><img src="/2019/01/23/权限管理-‘栗’子/image666.jpg"><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1-查询角色为Reader的的用户姓名？"><a href="#1-查询角色为Reader的的用户姓名？" class="headerlink" title="1.查询角色为Reader的的用户姓名？"></a>1.查询角色为Reader的的用户姓名？</h2><p>sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select u.username from t_user u,t_role r,user_role ur where r.name=&apos;Reader&apos; and r.id=ur.role_id and ur.user_id=u.id;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| username  |</span><br><span class="line">+-----------+</span><br><span class="line">| zhang san |</span><br><span class="line">| li si     |</span><br><span class="line">+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="2-查询wang-wu对应的角色？"><a href="#2-查询wang-wu对应的角色？" class="headerlink" title="2.查询wang wu对应的角色？"></a>2.查询wang wu对应的角色？</h2><p>sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select r.name from t_user u,t_role r,user_role ur where u.username=&apos;wang wu&apos; and u.id=ur.user_id and ur.role_id=r.id;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| name   |</span><br><span class="line">+--------+</span><br><span class="line">| Author |</span><br><span class="line">+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="3-查询拥有distribution权限的角色名？"><a href="#3-查询拥有distribution权限的角色名？" class="headerlink" title="3.查询拥有distribution权限的角色名？"></a>3.查询拥有distribution权限的角色名？</h2><p>sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select r.name from t_role r,t_authority a,role_authority ra where a.name=&apos;distribution&apos; and a.id=ra.authority_id and ra.role_id=r.id;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">| name  |</span><br><span class="line">+-------+</span><br><span class="line">| Admin |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="4-查询Author拥有的权限名？"><a href="#4-查询Author拥有的权限名？" class="headerlink" title="4.查询Author拥有的权限名？"></a>4.查询Author拥有的权限名？</h2><p>sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.name from t_role r,t_authority a,role_authority ra where r.name=&apos;Author&apos; and  r.id=ra.role_id and ra.authority_id=a.id;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">| name  |</span><br><span class="line">+-------+</span><br><span class="line">| wirte |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="5-查询qiao-feng用户拥有的权限名？"><a href="#5-查询qiao-feng用户拥有的权限名？" class="headerlink" title="5.查询qiao feng用户拥有的权限名？"></a>5.查询qiao feng用户拥有的权限名？</h2><p>sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.name from t_role r,t_authority a,role_authority ra where r.id=ra.role_id and authority_id=a.id and r.id in(select r.id from t_user u,t_role r,user_role ur where u.username=&apos;qiao feng&apos; and u.id=ur.user_id and ur.role_id=r.id);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">| name  |</span><br><span class="line">+-------+</span><br><span class="line">| wirte |</span><br><span class="line">+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="6-查询拥有cellction权限的用户名？"><a href="#6-查询拥有cellction权限的用户名？" class="headerlink" title="6.查询拥有cellction权限的用户名？"></a>6.查询拥有cellction权限的用户名？</h2><p>sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select u.username from t_role r,t_user u,user_role ur where r.id=ur.role_id and ur.user_id=u.id and r.id in (select r.id from t_role r,t_authority a,role_authority ra where a.name=&apos;cellction&apos; and a.id=ra.authority_id and ra.role_id=r.id);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| username  |</span><br><span class="line">+-----------+</span><br><span class="line">| zhang san |</span><br><span class="line">| li si     |</span><br><span class="line">+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于用户权限管理的简单栗子就介绍完了（有种迷恋写sql语句的感觉……..）。醒醒吧，还手写，shiro和spring security 两大框架还等着呢！ </p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/23/权限管理-‘栗’子/image1.jpg&quot;&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;权限管理MySql数据库设计，看下这里吧！&lt;/p&gt;
    
    </summary>
    
      <category term="权限管理" scheme="http://yoursite.com/categories/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="权限管理" scheme="http://yoursite.com/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>权限管理-概念</title>
    <link href="http://yoursite.com/2019/01/23/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/01/23/权限管理-概念/</id>
    <published>2019-01-23T07:27:42.000Z</published>
    <updated>2019-01-23T08:09:28.263Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/23/权限管理-概念/image1.jpg"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>权限管理，一般指根据系统设置的安全规则或者<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/2890163" target="_blank" rel="noopener">安全策略</a>，用户可以访问而且只能访问自己被授权的资源，不多不少。权限管理几乎出现在任何系统里面，只要有用户和密码的系统。 很多人常将“用户身份认证”、“密码加密”、“系统管理”等概念与权限管理概念混淆。</p><a id="more"></a><p>用户身份认证，不属于权限管理范畴。用户身份认证，是要解决这样的问题：用户告诉系统“我是谁”，系统就问用户凭什么证明你就是“谁”呢？对于采用用户名、密码验证的系统，那么就是出示密码。当用户名和密码匹配，则证明当前用户是谁；对于采用<a href="https://baike.baidu.com/item/%E6%8C%87%E7%BA%B9" target="_blank" rel="noopener">指纹</a>等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。</p><p>密码加密，是隶属用户身份认证领域，不属于权限管理范畴。</p><p>系统管理，一般是系统的一个模块。而且该模块一般还含有权限管理子模块。因此，很多人误认为权限管理系统只是系统的一个小小的子模块。系统管理里面的权限管理模块，只是一个操作界面，让企业IT管理员能够设置角色等<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" target="_blank" rel="noopener">安全策略</a>。系统背后还有很多权限验证逻辑，这些都并不属于该模块。总体来说，该模块相当于给权限管理模块提供了一些数据，比如：<a href="https://baike.baidu.com/item/%E5%BC%A0%E4%B8%89" target="_blank" rel="noopener">张三</a>是人力资源经理等。</p><p>更多混淆概念，请参考：《对权限管理认识的一些误区》。</p><p>以上概念来源于《百度百科》，个人也是很赞同的。关于身份认证，密码加密，后面将再单独整理！</p><p>下面将结合自己实际开发中的经验，表述对权限管理的理解。</p><h1 id="拙见"><a href="#拙见" class="headerlink" title="拙见"></a>拙见</h1><p>其实权限管理设计不麻烦，只要我们理解并参照RBAC模型（<a href="https://baike.baidu.com/item/RBAC/1328788?fr=aladdin" target="_blank" rel="noopener">Role-Based Access Control</a>），基本是可以应对所有应用场景。通俗来说就是一个账号对应一个或多个角色，每个角色对应相应的权限集，用户以角色为桥梁，实现灵活多样的权限操作。那么这其中有三个概念：账号，角色，权限。</p><h2 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h2><p>账号是每个用户进入系统的一把钥匙。</p><p>用户通过账号进入系统，目的只有一个，对资源进行CRUD操作，但至于用户操作权限到底有多大，还要由用户绑定的角色所具备的权限来决定。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>角色在管理系统中扮演桥梁的作用。</p><p>现实中，绝大多数场景都存在角色，如学校有老师，学生，校长等角色，而不同角色在学校里所拥有的权限不同，如校长有权决定开除一名“坏学生”，但普通老师不具备这样的权利，不是老师和校长这两个人存在权限区别，而是老师和校长这两个角色赋予了他们不同的操作权限。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>操作权限是用户登录系统后具体能做的一些事。</p><p>归纳起来可分为三种。</p><h3 id="页面权限"><a href="#页面权限" class="headerlink" title="页面权限"></a>页面权限</h3><p>决定你是否有权限查看某些个界面。</p><h3 id="操作权限"><a href="#操作权限" class="headerlink" title="操作权限"></a>操作权限</h3><p>控制你在页面上可以做那些操作。</p><h3 id="数据权限"><a href="#数据权限" class="headerlink" title="数据权限"></a>数据权限</h3><p>控制你可以访问那些数据。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>接下来将设计一个简单的权限管理数据库。大家放心，不会贴项目出来（论职业操守）！主要是帮助理解理顺权限管理的思路，保证只要遇到相关开发场景，立马有思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/23/权限管理-概念/image1.jpg&quot;&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;权限管理，一般指根据系统设置的安全规则或者&lt;a href=&quot;https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/2890163&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全策略&lt;/a&gt;，用户可以访问而且只能访问自己被授权的资源，不多不少。权限管理几乎出现在任何系统里面，只要有用户和密码的系统。 很多人常将“用户身份认证”、“密码加密”、“系统管理”等概念与权限管理概念混淆。&lt;/p&gt;
    
    </summary>
    
      <category term="权限管理" scheme="http://yoursite.com/categories/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="权限管理" scheme="http://yoursite.com/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>GitLab-基于Docker安装</title>
    <link href="http://yoursite.com/2019/01/22/GitLab-%E5%9F%BA%E4%BA%8EDocker%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/01/22/GitLab-基于Docker安装/</id>
    <published>2019-01-22T09:31:12.000Z</published>
    <updated>2019-01-22T09:54:29.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YML文件"><a href="#YML文件" class="headerlink" title="YML文件"></a>YML文件</h1><p>在<code>/usr/local/docker/gitlab</code>路径下使用如下命令创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>编辑内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">    web:</span><br><span class="line">      image: &apos;twang2218/gitlab-ce-zh:10.5&apos;</span><br><span class="line">      restart: always</span><br><span class="line">      hostname: &apos;你的虚拟机ip&apos;</span><br><span class="line">      environment:</span><br><span class="line">        TZ: &apos;Asia/Shanghai&apos;</span><br><span class="line">        GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">          external_url &apos;http://ip:8080&apos;</span><br><span class="line">          gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2222</span><br><span class="line">          unicorn[&apos;port&apos;] = 8888</span><br><span class="line">          nginx[&apos;listen_port&apos;] = 8080</span><br><span class="line">      ports:</span><br><span class="line">        - &apos;8080:8080&apos;</span><br><span class="line">        - &apos;8443:443&apos;</span><br><span class="line">        - &apos;2222:22&apos;</span><br><span class="line">      volumes:</span><br><span class="line">        - /usr/local/docker/gitlab/config:/etc/gitlab</span><br><span class="line">        - /usr/local/docker/gitlab/data:/var/opt/gitlab</span><br><span class="line">        - /usr/local/docker/gitlab/logs:/var/log/gitlab</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>可使用如下命令查看运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>打开浏览器，访问<a href="https://ip:8080，界面如下：" target="_blank" rel="noopener">https://ip:8080，界面如下：</a></p><img src="/2019/01/22/GitLab-基于Docker安装/image1.png"><p>注意：</p><p>1.先设置密码最好字母加数字，大于8位（记好了）；</p><p>2.默认管理员账号：root;</p><p>设置好后登陆如下：</p><img src="/2019/01/22/GitLab-基于Docker安装/image2.png"><p>登陆成功后主界面显示如下：</p><img src="/2019/01/22/GitLab-基于Docker安装/image3.jpg"><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>安装成功后，剩下便是如何使用GitLab，这里不赘述。</p>]]></content>
    
    <summary type="html">
    
      这里介绍使用 Docker 来安装和运行 GitLab 中文版。
    
    </summary>
    
      <category term="GitLab" scheme="http://yoursite.com/categories/GitLab/"/>
    
    
      <category term="GitLab" scheme="http://yoursite.com/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>GitLab-简介</title>
    <link href="http://yoursite.com/2019/01/22/GitLab-%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/01/22/GitLab-简介/</id>
    <published>2019-01-22T09:21:42.000Z</published>
    <updated>2019-01-22T09:29:58.314Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/01/22/GitLab-简介/image1.jpg"><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>GitLab</strong>是由GitLabInc.开发，使用<a href="https://baike.baidu.com/item/MIT%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">MIT许可证</a>的基于<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a>的<a href="https://baike.baidu.com/item/Git" target="_blank" rel="noopener">Git</a><a href="https://baike.baidu.com/item/%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">仓库</a>管理工具，且具有<a href="https://baike.baidu.com/item/wiki" target="_blank" rel="noopener">wiki</a>和issue跟踪功能。使用<a href="https://baike.baidu.com/item/Git" target="_blank" rel="noopener">Git</a>作为代码管理工具，并在此基础上搭建起来的web服务。</p><p>GitLab由乌克兰程序员DmitriyZaporozhets和ValerySizov开发，它由<a href="https://baike.baidu.com/item/Ruby" target="_blank" rel="noopener">Ruby</a>写成。后来，一些部分用<a href="https://baike.baidu.com/item/Go%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">Go语言</a>重写。截止2018年5月，该公司约有290名团队成员，以及2000多名开源贡献者。GitLab被IBM，Sony，JülichResearchCenter，NASA，Alibaba，Invincea，O’ReillyMedia，Leibniz-Rechenzentrum(LRZ)，CERN，SpaceX等组织使用。</p><p>GitLab 是利用 Ruby on Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 Github 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序 (Wall) 进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/01/22/GitLab-简介/image1.jpg&quot;&gt;
    
    </summary>
    
      <category term="GitLab" scheme="http://yoursite.com/categories/GitLab/"/>
    
    
      <category term="GitLab" scheme="http://yoursite.com/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose-实战MySql</title>
    <link href="http://yoursite.com/2019/01/22/Docker%20Compose-%E5%AE%9E%E6%88%98MySql/"/>
    <id>http://yoursite.com/2019/01/22/Docker Compose-实战MySql/</id>
    <published>2019-01-22T08:41:53.000Z</published>
    <updated>2019-01-22T09:00:45.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YML文件"><a href="#YML文件" class="headerlink" title="YML文件"></a>YML文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3.1&apos;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    command:</span><br><span class="line">      --default-authentication-plugin=mysql_native_password</span><br><span class="line">      --character-set-server=utf8mb4</span><br><span class="line">      --collation-server=utf8mb4_general_ci</span><br><span class="line">      --explicit_defaults_for_timestamp=true</span><br><span class="line">      --lower_case_table_names=1</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">  adminer:</span><br><span class="line">    image: adminer</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>打开浏览器，输入<code>https://ip:8080</code>显示如下：</p><img src="/2019/01/22/Docker%20Compose-实战MySql/image1.jpg">]]></content>
    
    <summary type="html">
    
      使用docker-compose.yml文件，运行mysql容器。
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker Compose" scheme="http://yoursite.com/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose-实战Tomcat</title>
    <link href="http://yoursite.com/2019/01/22/Docker%20Compose-%E5%AE%9E%E6%88%98Tomcat/"/>
    <id>http://yoursite.com/2019/01/22/Docker Compose-实战Tomcat/</id>
    <published>2019-01-22T08:41:36.000Z</published>
    <updated>2019-01-22T08:59:50.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YML文件"><a href="#YML文件" class="headerlink" title="YML文件"></a>YML文件</h1><p>在<code>/usr/local/docker/tomcat</code>文件夹下面创建<code>docker-compose.yml</code>文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>编辑内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;3.1&apos;</span><br><span class="line">services:</span><br><span class="line">  tomcat:</span><br><span class="line">    restart: always</span><br><span class="line">    image: tomcat</span><br><span class="line">    container_name: tomcat</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    volumes:</span><br><span class="line">      - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>注意：<code>-d</code> 是在后台运行。</p><p>打开浏览器，输入<code>https://ip:8080</code>显示tomcat官网。</p>]]></content>
    
    <summary type="html">
    
      这里演示使用docker-compose.yml文件，运行Tomcat容器。
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker Compose" scheme="http://yoursite.com/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose-基础</title>
    <link href="http://yoursite.com/2019/01/21/Docker%20Compose-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/01/21/Docker Compose-基础/</id>
    <published>2019-01-21T04:54:39.000Z</published>
    <updated>2019-01-22T09:01:25.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Compose 是 Docker 官方的开源项目，目的是实现对 Docker 容器集群的快速编排。</p><p>开源地址： <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p><p>官方文档：<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">https://docs.docker.com/compose/</a></p><p>在实际开发中，我们经常需要多个容器相互协调，共同实现某项业务，最典型的实现一个Web项目，需要Web服务容器本身，还需要数据库服务容器等等，这时我们可通过一个docker-compose.yml模板文件来定义一组相关联的容器，使之成为一个项目。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里只介绍Linux上二进制包安装。直接运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>完成后查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker-compose --version</span><br><span class="line">docker-compose version 1.17.1, build 6d101fb</span><br></pre></td></tr></table></figure><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="1-build"><a href="#1-build" class="headerlink" title="1.build"></a>1.build</h2><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h2 id="2-config"><a href="#2-config" class="headerlink" title="2.config"></a>2.config</h2><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h2 id="3-down"><a href="#3-down" class="headerlink" title="3.down"></a>3.down</h2><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h2 id="4-exec"><a href="#4-exec" class="headerlink" title="4.exec"></a>4.exec</h2><p>进入指定的容器。</p><h2 id="5-help"><a href="#5-help" class="headerlink" title="5.help"></a>5.help</h2><p>获得一个命令的帮助。</p><h2 id="6-images"><a href="#6-images" class="headerlink" title="6.images"></a>6.images</h2><p>列出 Compose 文件中包含的镜像。</p><h2 id="7-kill"><a href="#7-kill" class="headerlink" title="7.kill"></a>7.kill</h2><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h2 id="8-logs"><a href="#8-logs" class="headerlink" title="8.logs"></a>8.logs</h2><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h2 id="9-pause"><a href="#9-pause" class="headerlink" title="9.pause"></a>9.pause</h2><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><p>暂停一个服务容器。</p><h2 id="10-port"><a href="#10-port" class="headerlink" title="10.port"></a>10.port</h2><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h2 id="11-ps"><a href="#11-ps" class="headerlink" title="11.ps"></a>11.ps</h2><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h2 id="12-pull"><a href="#12-pull" class="headerlink" title="12.pull"></a>12.pull</h2><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h2 id="13-push"><a href="#13-push" class="headerlink" title="13.push`"></a>13.push`</h2><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h2 id="14-restart"><a href="#14-restart" class="headerlink" title="14.restart"></a>14.restart</h2><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h2 id="15-rm"><a href="#15-rm" class="headerlink" title="15.rm"></a>15.rm</h2><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h2 id="16-run"><a href="#16-run" class="headerlink" title="16.run"></a>16.run</h2><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h2 id="17-scale"><a href="#17-scale" class="headerlink" title="17.scale"></a>17.scale</h2><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h2 id="18-start"><a href="#18-start" class="headerlink" title="18.start"></a>18.start</h2><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h2 id="19-stop"><a href="#19-stop" class="headerlink" title="19.stop"></a>19.stop</h2><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h2 id="20-top"><a href="#20-top" class="headerlink" title="20.top"></a>20.top</h2><p>查看各个服务容器内运行的进程。</p><h2 id="21-unpause"><a href="#21-unpause" class="headerlink" title="21.unpause"></a>21.unpause</h2><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h2 id="22-up"><a href="#22-up" class="headerlink" title="22.up"></a>22.up</h2><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h2 id="23-version"><a href="#23-version" class="headerlink" title="23.version"></a>23.version</h2><p>格式为 <code>docker-compose version</code>。</p><h1 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">examples/web</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/data"</span></span><br></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h3><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./dir</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="attr">        buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  context:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">  cache_from:</span></span><br><span class="line"><span class="attr">    - alpine:</span><span class="string">latest</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure><h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h3><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">NET_ADMIN</span></span><br></pre></td></tr></table></figure><h3 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h3><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h3><p>仅用于 <code>Swarm mode</code></p><h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h3><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">cgroups_1</span></span><br></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h3><p>仅用于 <code>Swarm mode</code></p><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h3><p>指定设备映射关系。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h3><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h3><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure><h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h3><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain1.example.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure><h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h3><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/run</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h3><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">  RACK_ENV:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">  SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="http://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h3><blockquote><p>注意：不建议使用该指令。</p></blockquote><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">external_links:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">redis_1</span></span><br><span class="line"><span class="attr"> - project_db_1:</span><span class="string">mysql</span></span><br><span class="line"><span class="attr"> - project_db_1:</span><span class="string">postgresql</span></span><br></pre></td></tr></table></figure><h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h3><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h3><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"><span class="attr">  test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  interval:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure><h3 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h3><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">com.startupteam.description:</span> <span class="string">"webapp for a startup team"</span></span><br><span class="line">  <span class="string">com.startupteam.department:</span> <span class="string">"devops department"</span></span><br><span class="line">  <span class="string">com.startupteam.release:</span> <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><h3 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h3><blockquote><p>注意：不推荐使用该指令。</p></blockquote><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h3><p>配置日志选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  driver:</span> <span class="string">syslog</span></span><br><span class="line"><span class="attr">  options:</span></span><br><span class="line"><span class="attr">    syslog-address:</span> <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line"><span class="attr">  max-size:</span> <span class="string">"200k"</span></span><br><span class="line"><span class="attr">  max-file:</span> <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h3><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h3><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  some-service:</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">some-network</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  some-network:</span></span><br><span class="line"><span class="attr">  other-network:</span></span><br></pre></td></tr></table></figure><h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h3><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">"host"</span></span><br></pre></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h3><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"8000:8000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"49100:22"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"127.0.0.1:8001:8001"</span></span><br></pre></td></tr></table></figure><p><em>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h3><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_root_password</span></span><br><span class="line"><span class="attr">  secrets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">db_root_password</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">my_other_secret</span></span><br><span class="line"></span><br><span class="line"><span class="attr">secrets:</span></span><br><span class="line"><span class="attr">  my_secret:</span></span><br><span class="line"><span class="attr">    file:</span> <span class="string">./my_secret.txt</span></span><br><span class="line"><span class="attr">  my_other_secret:</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">user:USER</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">role:ROLE</span></span><br></pre></td></tr></table></figure><h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h3><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span></span><br></pre></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h3><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="string">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="string">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h3><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line"><span class="attr">  nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">  nofile:</span></span><br><span class="line"><span class="attr">    soft:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">    hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h3><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure><h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><p>指定器中工作目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">working_dir:</span> <span class="string">/code</span></span><br></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">domainname:</span> <span class="string">your_website.com</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">mac_address:</span> <span class="number">08</span><span class="bullet">-00</span><span class="bullet">-27</span><span class="bullet">-00</span><span class="bullet">-0</span><span class="string">C-0A</span></span><br></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stdin_open:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code>的值，并写入执行的指令中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">"mongo:$&#123;MONGO_VERSION&#125;"</span></span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持 # 号注释</span></span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这里记录的命令比较多，过一遍即可！</p>]]></content>
    
    <summary type="html">
    
      这里整理记录Docker-compose使用中可能涉及的命令，大致过一遍，有个印象便可。
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker Compose" scheme="http://yoursite.com/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Docker-常用命令</title>
    <link href="http://yoursite.com/2019/01/20/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/01/20/Docker-常用命令/</id>
    <published>2019-01-20T07:45:43.000Z</published>
    <updated>2019-01-20T07:54:28.741Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1.查看 Docker 版本：docker version</span><br><span class="line"></span><br><span class="line">2.从 Docker 文件构建 Docker 映像：docker build -t image-name docker-file-location</span><br><span class="line"></span><br><span class="line">3.运行 Docker 映像：docker run -d image-name</span><br><span class="line"></span><br><span class="line">4.查看可用的 Docker 映像：docker images</span><br><span class="line"></span><br><span class="line">5.查看最近的运行容器：docker ps -l</span><br><span class="line"></span><br><span class="line">6.查看所有正在运行的容器：docker ps -a</span><br><span class="line"></span><br><span class="line">7.停止运行容器：docker stop container_id</span><br><span class="line"></span><br><span class="line">8.删除一个镜像：docker rmi image-name</span><br><span class="line"></span><br><span class="line">9.删除所有镜像：docker rmi $(docker images -q)</span><br><span class="line"></span><br><span class="line">10.强制删除所有镜像：docker rmi -r $(docker images -q)</span><br><span class="line"></span><br><span class="line">11.删除所有虚悬镜像：docker rmi $(docker images -q -f dangling=true)</span><br><span class="line"></span><br><span class="line">12.删除所有容器：docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">13.进入 Docker 容器：docker exec -it container-id /bin/bash</span><br><span class="line"></span><br><span class="line">14.查看所有数据卷：docker volume ls</span><br><span class="line"></span><br><span class="line">15.删除指定数据卷：docker volume rm [volume_name]</span><br><span class="line"></span><br><span class="line">16.删除所有未关联的数据卷：docker volume rm $(docker volume ls -qf dangling=true)</span><br><span class="line"></span><br><span class="line">17.从主机复制文件到容器：sudo docker cp host_path containerID:container_path</span><br><span class="line"></span><br><span class="line">18.从容器复制文件到主机：sudo docker cp containerID:container_path host_path</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这里将列举比较常用的Docker命令。
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="常用命令" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker-MySql</title>
    <link href="http://yoursite.com/2019/01/20/Docker-MySql/"/>
    <id>http://yoursite.com/2019/01/20/Docker-MySql/</id>
    <published>2019-01-20T03:19:12.000Z</published>
    <updated>2019-01-21T06:59:08.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>我们可先使用如下命令，查询Docker Hub上关于MySql相关信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/docker/mysql# docker search mysql</span><br></pre></td></tr></table></figure><h1 id="获取MySql"><a href="#获取MySql" class="headerlink" title="获取MySql"></a>获取MySql</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/docker/mysql# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">177e7ef0df69: Pull complete </span><br><span class="line">cac25352c4c8: Pull complete </span><br><span class="line">8585afabb40a: Pull complete </span><br><span class="line">1e4af4996053: Pull complete </span><br><span class="line">c326522894da: Pull complete </span><br><span class="line">9020d6b6b171: Pull complete </span><br><span class="line">55eb37ec6e5f: Pull complete </span><br><span class="line">37f3f3d72fbd: Pull complete </span><br><span class="line">03f098d64268: Pull complete </span><br><span class="line">46a52a54cfe9: Pull complete </span><br><span class="line">202bc662895d: Pull complete </span><br><span class="line">46014f07b258: Pull complete </span><br><span class="line">Digest: sha256:196c04e1944c5e4ea3ab86ae5f78f697cf18ee43865f25e334a6ffb1dbea81e6</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/docker/mysql# docker run -p 3306:3306 --name mysql \</span><br><span class="line"> -v /usr/local/docker/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line"> -v /usr/local/docker/mysql/logs:/var/log/mysql \</span><br><span class="line"> -v /usr/local/docker/mysql/data:/var/lib/mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line"> -d mysql</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>-p 3306:3306</code>：将容器的3306端口映射到主机的3306端口</li><li><code>-v /usr/local/docker/mysql/conf:/etc/mysql/conf.d</code>：将主机当前目录下的 conf 挂载到容器的 <code>/etc/mysql/conf.d</code></li><li><code>-v /usr/local/docker/mysql/logs:/var/log/mysql</code>：将主机当前目录下的 logs 目录挂载到容器的<code>/var/log/mysql</code></li><li><code>-v /usr/local/docker/mysql/data:/var/lib/mysql</code>：将主机当前目录下的 data 目录挂载到容器的 <code>/var/lib/mysql</code></li><li><code>-e MYSQL\_ROOT\_PASSWORD=123456</code>：初始化root用户的密码</li></ul><h1 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker ps</span><br></pre></td></tr></table></figure><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>STATUS</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>3d04b5c68a08</td><td>mysql</td><td>“docker-entrypoint.s…”</td><td>8 minutes ago</td><td>Up 8 minutes</td><td>0.0.0.0:3306-&gt;3306/tcp, 33060/tcp</td><td>mysql</td></tr></tbody></table><p>使用SQLyog链接不上，并抛出如下问题：</p><img src="/2019/01/20/Docker-MySql/mysqlError1.jpg"><p>原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password</span><br></pre></td></tr></table></figure><p>方案：</p><p>我们把mysql用户登录密码加密规则还原成mysql_native_password。</p><p>步骤：</p><p>1.进入容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 3d0 bash</span><br></pre></td></tr></table></figure><p>2.链接mysql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@3d04b5c68a08:/# mysql -uroot -p</span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure><p>3.配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER  USER  &apos;root&apos;  IDENTIFIED  WITH  mysql_native_password  BY  &apos;123456&apos;;</span><br></pre></td></tr></table></figure><p>5.然后再使用SQLyog测试链接，成功！</p><img src="/2019/01/20/Docker-MySql/mysqlError2.jpg">]]></content>
    
    <summary type="html">
    
      这里将记录在Docker上构建MySql。
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="MySql" scheme="http://yoursite.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Positive Discipline-初衷</title>
    <link href="http://yoursite.com/2019/01/19/Positive-Discipline-%E5%88%9D%E8%A1%B7/"/>
    <id>http://yoursite.com/2019/01/19/Positive-Discipline-初衷/</id>
    <published>2019-01-19T06:52:49.000Z</published>
    <updated>2019-01-21T04:43:50.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    在《孩子，把你的手给我》书中这样说：我们不但要有一颗爱孩子的心，更要懂得如何去爱孩子。我知道这句话前部分是为人父母最基本的品质，但重点在后面一部分，如何去爱孩子？重点在于爱的表现方式上，最典型笼统式的两种常见方式是溺爱和惩罚，当然这都是极端，是不太可取的。但准爸妈们是否有过自问：我该如何正确的爱孩子？</p><h1 id="我的初衷"><a href="#我的初衷" class="headerlink" title="我的初衷"></a>我的初衷</h1><p>​    16年5月15日，注定是我人生意义非凡的一天—大女儿出生。记得当时，产房外，得知母女平安后，我激动的哭了出来。</p><p>​    女儿出生，给我们两个原生家庭带来了无限幸福感。刚开始，亲戚朋友见了面，都会相互恭喜，恭喜什么？无外乎就是，恭喜你做爷爷，做奶奶，做伯伯……到后来，时间稍长些，新奇感便也渐渐淡下来，更多便是孩子如何与自己与周遭相处的事儿。</p><p>​    陪伴孩子成长中，我和老婆刚开始不察觉，但现在来看，原来我们也变了很多。孩子出生后，老婆变各种育儿科普–育儿书籍.网站论坛。慢慢也形成了自己一套育儿理论方式，想在同辈里的宝妈们，大多会主动向她请教育儿经。当然，我只是站在老公的角度看待这些客观现象，但老婆做出这些学习的行动以及能坚持这些行为的内在驱动力，似乎应该是很少去尝试理解（但这也成为现在打心底佩服老婆的原因）。</p><p>​    我心里，只有未来。关于宝贝的未来，我思考了很多，似乎得出的结论只有一个：我得好好挣钱！一个总是思考未来的爸爸，必然会忽视很多当下的细节！这估计也是偶尔跟老婆在关于育儿方面起争执的症结所在吧！</p><p>​    最近，女儿慢慢成长了，2岁半，上了蒙氏幼儿园。在学校老师们用心的喂了点“盐”，经常在家就是：爸爸，没经过我的允许，你不可以怎样怎样。当然我是非常认可老师们教会宝贝们正确表达自己。只是很多时候，孩子会用“哭闹”这种方式来表达自己的诉求，不对，准确说是，我有种被要挟然后被打败的感觉！</p><p>​    和孩子的博弈每天都会上演，剧情一般是这样。</p><p>​    “爸爸，我要…….(需求)”</p><p>​    “不可以”</p><p>​    “呜呜呜……啊啊啊啊啊……”</p><p>​    如果需求正常，到好，满足便是，父女相安无事！但宝贝经常会提一些不合时，不合适的要求，作为爸爸能全部满足吗？当然是不可以。可越是孩子长大，精力越盛，面对她的各种哭诉，我的确是疲于应对，但自己的宝贝，不能说采取恐吓威胁，武力解决，亦或是百依百顺，这样子，实在不敢想象，今后会教出怎样的孩子。</p><p>​    “你要用和善而坚定的态度拒绝宝贝的不合理需求…..”，老婆对我说过的这句话，我一直没深究它的出处。也就是今天我得到了答案，在老婆之前看过的一本书里–《Positive Discipline 正面管教》。</p><p>​    《Positive Discipline 正面管教》是由美籍作家Jane Nelsen(简.尼尔森)著，由中国作家王冰译。简.尼尔森是一名教育学博士，杰出的心理学家，教育家，反正是个“大家”，当然作者的社会荣誉，倒不是我最关心的，当我看到介绍，作者是7个孩子的母亲，22个孩子的祖母或外祖母，还是两个孩子的曾祖母，我开始好奇了！作者是如何面对和处理与子女关系的。</p><p>​    书中译者王冰在使用了《Positive Discipline 正面管教》里面提及的系列正面管教方法后，按她自己的原话”我很快发现自己可以不再需要’克制’自己，开始自然而然地‘出乎本能‘地改变着我和孩子之间的相处模式。孩子也因此变得更配合，更可爱。我如饥似渴地读下去，不知不觉进入一个豁然开朗的新天地”。译者王冰的自述，不正是我内心所渴望的吗。</p><p>​    另外译者还提及翻译《Positive Discipline 正面管教》一书的初衷，当然我的思想境界可能还未达到她那个高度，用我自己的话来说“我希望，使用有效的，正面的方法管教孩子，让孩子在自信，自立的快乐环境中健康成长，把良好的行为品德，有益的社会技能深深植入孩子心底”。这也是我的初衷！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>​    思考下：如何不惩罚，不骄纵地有效管教孩子！</p><p>​    </p><p>​    </p>]]></content>
    
    <summary type="html">
    
      在《孩子，把你的手给我》书中这样说：我们不但要有一颗爱孩子的心，更要懂得如何去爱孩子。我知道这句话前部分是为人父母最基本的品质，但重点在后面一部分，如何去爱孩子？重点在于爱，表现的方式上，最典型笼统式的两种常见方式是溺爱和惩罚，当然这都是两种极端，我们都是不赞同的。但准爸妈们是否有过自问：我该如何正确的爱孩子？
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Positive Discipline" scheme="http://yoursite.com/tags/Positive-Discipline/"/>
    
      <category term="正面管教" scheme="http://yoursite.com/tags/%E6%AD%A3%E9%9D%A2%E7%AE%A1%E6%95%99/"/>
    
      <category term="育儿" scheme="http://yoursite.com/tags/%E8%82%B2%E5%84%BF/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Tomcat</title>
    <link href="http://yoursite.com/2019/01/19/Docker-Tomcat/"/>
    <id>http://yoursite.com/2019/01/19/Docker-Tomcat/</id>
    <published>2019-01-19T06:50:12.000Z</published>
    <updated>2019-01-20T03:15:58.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Hub上查找Tomcat"><a href="#Docker-Hub上查找Tomcat" class="headerlink" title="Docker Hub上查找Tomcat"></a>Docker Hub上查找Tomcat</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/docker/tomcat# docker search tomcat</span><br><span class="line">NAME                                       DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">tomcat                                     Apache Tomcat is an open source implementati…   2259                [OK]                </span><br><span class="line">tomee                                      Apache TomEE is an all-Apache Java EE certif…   60                  [OK]                </span><br><span class="line">dordoka/tomcat                             Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 base…   51                                      [OK]</span><br><span class="line">davidcaste/alpine-tomcat                   Apache Tomcat 7/8 using Oracle Java 7/8 with…   34                                      [OK]</span><br><span class="line">bitnami/tomcat                             Bitnami Tomcat Docker Image                     27                                      [OK]</span><br><span class="line">consol/tomcat-7.0                          Tomcat 7.0.57, 8080, &quot;admin/admin&quot;              16                                      [OK]</span><br><span class="line">cloudesire/tomcat                          Tomcat server, 6/7/8                            14                                      [OK]</span><br><span class="line">tutum/tomcat                               Base docker image to run a Tomcat applicatio…   11                                      </span><br><span class="line">meirwa/spring-boot-tomcat-mysql-app        a sample spring-boot app using tomcat and My…   10                                      [OK]</span><br><span class="line">aallam/tomcat-mysql                        Debian, Oracle JDK, Tomcat &amp; MySQL              10                                      [OK]</span><br><span class="line">jeanblanchard/tomcat                       Minimal Docker image with Apache Tomcat         8                                       </span><br><span class="line">arm32v7/tomcat                             Apache Tomcat is an open source implementati…   6                                       </span><br><span class="line">rightctrl/tomcat                           CentOS , Oracle Java, tomcat application ssl…   3                                       [OK]</span><br><span class="line">maluuba/tomcat7-java8                      Tomcat7 with java8.                             3                                       </span><br><span class="line">fabric8/tomcat-8                           Fabric8 Tomcat 8 Image                          2                                       [OK]</span><br><span class="line">amd64/tomcat                               Apache Tomcat is an open source implementati…   2                                       </span><br><span class="line">arm64v8/tomcat                             Apache Tomcat is an open source implementati…   2                                       </span><br><span class="line">99taxis/tomcat7                            Tomcat7                                         1                                       [OK]</span><br><span class="line">cfje/tomcat-resource                       Tomcat Concourse Resource                       0                                       </span><br><span class="line">1and1internet/debian-9-java-8-tomcat-8.5   Our tomcat 8.5 image                            0                                       [OK]</span><br><span class="line">s390x/tomcat                               Apache Tomcat is an open source implementati…   0                                       </span><br><span class="line">jelastic/tomcat                            An image of the Tomcat Java application serv…   0                                       </span><br><span class="line">picoded/tomcat7                            tomcat7 with jre8 and MANAGER_USER / MANAGER…   0                                       [OK]</span><br><span class="line">oobsri/tomcat8                             Testing CI Jobs with different names.           0                                       </span><br><span class="line">swisstopo/service-print-tomcat             backend tomcat for service-print &quot;the true, …   0</span><br></pre></td></tr></table></figure><h1 id="拉取官方镜像"><a href="#拉取官方镜像" class="headerlink" title="拉取官方镜像"></a>拉取官方镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/docker/tomcat# docker pull tomcat</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">cd8eada9c7bb: Pull complete </span><br><span class="line">c2677faec825: Pull complete </span><br><span class="line">fcce419a96b1: Pull complete </span><br><span class="line">00d7fcb5828a: Pull complete </span><br><span class="line">f8c860563d60: Pull complete </span><br><span class="line">46f754145d12: Pull complete </span><br><span class="line">bff15a87739e: Pull complete </span><br><span class="line">6b5d3f0336b9: Pull complete </span><br><span class="line">1d858972966c: Pull complete </span><br><span class="line">4f2dc2e148d0: Pull complete </span><br><span class="line">db18a2f7d48d: Pull complete </span><br><span class="line">Digest: sha256:fd162e0f238deae5b7028934377abc40658e82d7c9b2a0038546466bb0d89e6d</span><br><span class="line">Status: Downloaded newer image for tomcat:latest</span><br></pre></td></tr></table></figure><h1 id="运行Tomcat"><a href="#运行Tomcat" class="headerlink" title="运行Tomcat"></a>运行Tomcat</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/docker/tomcat# docker run --name tomcat -p 8080:8080 -d tomcat</span><br><span class="line">dfdccb5fb79403a3111d99f381afc9ad92a1aeb7e06d6f51846c142a6ebced87</span><br><span class="line">root@mkin:/usr/local/docker/tomcat# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">dfdccb5fb794        tomcat              &quot;catalina.sh run&quot;   11 seconds ago      Up 10 seconds       0.0.0.0:8080-&gt;8080/tcp   tomcat</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>打开浏览器输入：<code>http://192.168.20.141:8080/</code>(以自己虚拟机ip地址为准)。显示如下：</p><img src="/2019/01/19/Docker-Tomcat/image1.jpg">]]></content>
    
    <summary type="html">
    
      这里我们将在Docker上构建Tomcat镜像，并将其运行起来。
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Docker-仓库</title>
    <link href="http://yoursite.com/2019/01/19/Docker-%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2019/01/19/Docker-仓库/</id>
    <published>2019-01-19T06:49:50.000Z</published>
    <updated>2019-01-19T10:10:10.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><a id="more"></a><h1 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h1><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p>地址： <a href="https://cloud.docker.com" target="_blank" rel="noopener">https://cloud.docker.com</a></p><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>以centos为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search centos</span><br><span class="line"></span><br><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br></pre></td></tr></table></figure><h1 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h1><h2 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h2><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><h2 id="私有仓库操作"><a href="#私有仓库操作" class="headerlink" title="私有仓库操作"></a>私有仓库操作</h2><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY     TAG       IMAGE ID      CREATED     VIRTUAL SIZE</span><br><span class="line">ubuntu       latest     ba5877dc9bec  6 weeks ago     192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker push 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>用 <code>curl</code> 查看仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;<span class="string">"repositories"</span>:[<span class="string">"ubuntu"</span>]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;repositories&quot;:[&quot;ubuntu&quot;]}</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1.Ubuntu 16.04+, Debian 8+, centos 7</p><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"192.168.199.100:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前 Docker 官方维护了一个公共仓库 &lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Hub&lt;/a&gt;，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Docker Hub" scheme="http://yoursite.com/tags/Docker-Hub/"/>
    
  </entry>
  
  <entry>
    <title>Docker-容器</title>
    <link href="http://yoursite.com/2019/01/19/Docker-%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/01/19/Docker-容器/</id>
    <published>2019-01-19T06:49:30.000Z</published>
    <updated>2019-01-19T09:55:50.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>概念性的内容前面已经做过铺垫，这里不再赘述，直接进入实操！</p><a id="more"></a><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>主要为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><p>启动一个bash终端，允许用户进行交互：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/nginx# docker images</span><br><span class="line">REPOSITORY     TAG         IMAGE ID        CREATED           SIZE</span><br><span class="line">nginx          v3        fcd07ecaa685    33 minutes ago      109MB</span><br><span class="line">nginx         latest     7042885a156a     3 weeks ago        109MB</span><br><span class="line">hello-world   latest     4ab4c602aa5e     4 months ago       1.84kB</span><br><span class="line"></span><br><span class="line">root@mkin:/usr/local/nginx# docker run -t -i fcd07ecaa685  /bin/bash</span><br><span class="line">root@58193836306b:/#</span><br></pre></td></tr></table></figure><p>退出容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@58193836306b:/# exit   </span><br><span class="line">exit</span><br><span class="line">root@mkin:/usr/local/nginx#</span><br></pre></td></tr></table></figure><p>另外可通过如下命令将一个已经终止的容器启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container start</span><br></pre></td></tr></table></figure><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>我们可使用<code>docker container stop</code>来终止一个容器。</p><p>另外，只启动了一个终端的容器，通过 <code>exit</code> 命令或 <code>Ctrl+d</code>来退出终端时，所创建的容器立刻终止。</p><p>通过如下命令查看终止状态的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure><p>然后再通过<code>docker container start</code>来启动容器，另外<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/nginx# docker exec -it 58193836306b /bin/bash</span><br><span class="line">root@58193836306b:/# exit</span><br><span class="line">exit</span><br><span class="line">root@mkin:/usr/local/nginx# docker container ls -a</span><br></pre></td></tr></table></figure><p>使用这种方式进入容器，然后使用<code>exit</code>推出容器，不会导致容器停止。</p><p>而另外一种<code>attach</code>当使用<code>exit</code>退出容器时，会导致容器停止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/nginx# docker attach 58193836306b</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;概念性的内容前面已经做过铺垫，这里不再赘述，直接进入实操！&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker-镜像</title>
    <link href="http://yoursite.com/2019/01/19/Docker-%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2019/01/19/Docker-镜像/</id>
    <published>2019-01-19T06:49:02.000Z</published>
    <updated>2019-01-19T09:35:39.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经介绍了什么是Docker，为什么要使用Docker,以及其它一些关于Docker的相关概念，目的是加身对Docker的理解。其中就有介绍过Docker镜像这个概念（这里就不展开说），接下来我们要知道如何使用Docker镜像，以及如何使用Dockerfile定制镜像。</p><a id="more"></a><h1 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>注意：</p><p>1.地址格式一般是 &lt;域名/IP&gt;[:端口号] ，默认地址是Docker Hub；</p><p>2.仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;,对于Docker Hub，如果不给出用户名，则默认为library，也即是官方镜像。</p><p>例子：获取ubuntu镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker pull ubuntu:16.04</span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">b849b56b69e7: Pull complete </span><br><span class="line">42986ef25bcd: Pull complete </span><br><span class="line">d927c1b717ec: Pull complete </span><br><span class="line">15b86ea20233: Pull complete </span><br><span class="line">Digest: sha256:b967b9f2a5625231a22db642609e61b7b1a5481128f51fe771e91bb92e0a35d0</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure><p>注意：</p><p>1.仔细观察下载过程，是符合前面提及的分层存储的概念，终端显示了每一层的ID的前12位。另外下载完成后也给出了镜像完整的sha256摘要。</p><p>2.如果下载镜像缓慢，记得参考前面，配置加速。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>这里我们以前面获取的ubuntu镜像为基础，启动并运行一个容器。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker run -it --rm ubuntu:16.04 bash  </span><br><span class="line">root@d22246635fdc:/# cat /etc/os-release</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;16.04.5 LTS (Xenial Xerus)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 16.04.5 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;16.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line">root@d22246635fdc:/# </span><br><span class="line">root@d22246635fdc:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>注意：</p><p>1.其中docker run 便是运行容器的命令；</p><p>2.-it: -i是交互式操作；-t是终端；</p><p>3.-rm: 在容器退出后将其删除，避免测试时，浪费空间；</p><p>4.ubuntu：16.04： 是指用ubuntu：16.04镜像为基础来启动容器；</p><p>5.bash是放在镜像名后的命令，表示我们希望有交互式shell，因此使用的是bash;</p><p>6.进入容器后，我们执行了cat /etc/os-release命令，这是查看当前系统版本的命令。</p><p>7.exit:退出容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               b0ef3016420a        3 weeks ago         117MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        4 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>注意：</p><p>1.体积：ubuntu在Docker Hub上和这里显示的体积大小是不一样的。这是因为这里显示的是镜像下载到本地展开后的大小，Docker Hub上显示的是压缩后的大小。</p><p>另外需要注意的是，这里列出的镜像体积总和并不一定是镜像实际占用的体积，因为Docker镜像采用的是多层存储结构，可以继承，复用，所以不同镜像可能使用相同的镜像基础，所以这里列出的镜像体积可能比实际镜像占用的体积大些。</p><p>查看镜像，容器，数据卷所占空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              2                   1                   116.7MB             116.7MB (99%)</span><br><span class="line">Containers          1                   0                   0B                  0B</span><br><span class="line">Local Volumes       0                   0                   0B                  0B</span><br><span class="line">Build Cache         0                   0                   0B                  0B</span><br></pre></td></tr></table></figure><h2 id="dangling-image"><a href="#dangling-image" class="headerlink" title="dangling image"></a>dangling image</h2><p>使用docker image ls命令查看镜像时如果有显示为<code>&lt;none&gt;</code>的镜像，即为<code>dangling image</code>。出现原因：</p><ol><li><p><code>docker pull</code> 可能导致这种情况;</p></li><li><p><code>docker build</code> 也同样可以导致这种现象。</p><p>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。</p></li></ol><p>可使用如下命令专门显示<code>dangling image</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure><p>删除<code>dangling image</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="显示所有包括中间层在内的镜像"><a href="#显示所有包括中间层在内的镜像" class="headerlink" title="显示所有包括中间层在内的镜像"></a>显示所有包括中间层在内的镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><p>注意：加速镜像构建、重复利用资源，Docker 会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果想显示中间层镜像，需要使用<code>-a</code>参数。</p><p>这样会有很多没有标签的镜像，与前面的<code>dangling image</code>不同，这些无标签的镜像都是中间层镜像，是其它镜像所依赖的镜像，不应该被删除。</p><h2 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls ubuntu</span><br></pre></td></tr></table></figure><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>先列出镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               b0ef3016420a        3 weeks ago         117MB</span><br><span class="line">hello-world         latest              4ab4c602aa5e        4 months ago        1.84kB</span><br></pre></td></tr></table></figure><p>使用<code>imgae ID</code>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:~# docker image rm b0e</span><br><span class="line">Untagged: ubuntu:16.04</span><br><span class="line">Untagged: ubuntu@sha256:b967b9f2a5625231a22db642609e61b7b1a5481128f51fe771e91bb92e0a35d0</span><br><span class="line">Deleted: sha256:b0ef3016420a4052400d0a36f5144ebdee5d358ef6942afee072517b5a94168c</span><br><span class="line">Deleted: sha256:7c42fc68785f05435c7d0a15ab5eba645dd51431ff85ba8c81aac71b6d7fa676</span><br><span class="line">Deleted: sha256:9ae10a8fb5d0419283b7d8ede59c6cb17df79c1bc0f0367ad5d5fd5f9040b9b7</span><br><span class="line">Deleted: sha256:8c7764429ac5850455be6b16dcbf2f3e916522ea400c90133b498701debfe3a2</span><br><span class="line">Deleted: sha256:8241afc74c6f5ca20c3bd7f3ddb3e5621d637ee85aaf40de440bf465b2a9984f</span><br></pre></td></tr></table></figure><p>注意：</p><p>1.ID可以是完整的，也可以是ID的前三位即可;</p><p>2.也可以使用<code>docker image rm &lt;仓库名如centos&gt;</code>;</p><p>3.也可食用<code>docker image rm 镜像摘要</code>。</p><p>4.删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><h2 id="配合docker-image-ls"><a href="#配合docker-image-ls" class="headerlink" title="配合docker image ls"></a>配合docker image ls</h2><p>删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><p>删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h2><p>以定制<code>ngnix</code>镜像为例：</p><p>1.在<code>/usr/local/</code>路径下创建<code>nginx</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nginx</span><br></pre></td></tr></table></figure><p>2.进入<code>nginx</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx</span><br></pre></td></tr></table></figure><p>3.创建并编辑<code>Dockerfile</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>编辑内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>4.构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/<span class="built_in">local</span>/nginx<span class="comment"># docker build -t nginx:v3 .</span></span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">177e7ef0df69: Pull complete </span><br><span class="line">ea57c53235df: Pull complete </span><br><span class="line">bbdb1fbd4a86: Pull complete </span><br><span class="line">Digest: sha256:b543f6d0983fbc25b9874e22f4fe257a567111da96fd1d8f1b44315f1236398c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br><span class="line"> ---&gt; 7042885a156a</span><br><span class="line">Step 2/2 : RUN <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 498081e4a8f3</span><br><span class="line">Removing intermediate container 498081e4a8f3</span><br><span class="line"> ---&gt; fcd07ecaa685</span><br><span class="line">Successfully built fcd07ecaa685</span><br><span class="line">Successfully tagged nginx:v3</span><br></pre></td></tr></table></figure><p>5.查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/nginx# docker image ls</span><br><span class="line">REPOSITORY          TAG         IMAGE ID        CREATED             SIZE</span><br><span class="line">nginx               v3        fcd07ecaa685     9 seconds ago       109MB</span><br></pre></td></tr></table></figure><p>6.运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/nginx# docker run --name mynginx -d fcd07ecaa685</span><br><span class="line">eade36419390f809357fbe7eaa93df2448b64a8c5928315972552fb902cc935f</span><br></pre></td></tr></table></figure><p>7.运行容器查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@mkin:/usr/local/nginx# docker ps</span><br></pre></td></tr></table></figure><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>STATUS</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>eade36419390</td><td>fcd07ecaa685</td><td>“nginx -g’daemon of…”</td><td>54 seconds ago</td><td>Up 52 seconds</td><td>80/tcp</td><td>mynginx</td></tr></tbody></table><h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><p>请参考：</p><p>Dockerfie 官方文档](<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面已经介绍了什么是Docker，为什么要使用Docker,以及其它一些关于Docker的相关概念，目的是加身对Docker的理解。其中就有介绍过Docker镜像这个概念（这里就不展开说），接下来我们要知道如何使用Docker镜像，以及如何使用Dockerfile定制镜像。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="镜像" scheme="http://yoursite.com/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>SSH-Win10使用SSH免密拉取GitLab代码</title>
    <link href="http://yoursite.com/2019/01/17/SSH-Win10%E4%BD%BF%E7%94%A8SSH%E5%85%8D%E5%AF%86%E6%8B%89%E5%8F%96GitLab%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/01/17/SSH-Win10使用SSH免密拉取GitLab代码/</id>
    <published>2019-01-17T05:42:07.000Z</published>
    <updated>2019-01-17T05:52:58.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>1.打开电脑终端 cd 进入文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\usr\bin</span><br></pre></td></tr></table></figure><p>2.运行如下密令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;maojing&quot;</span><br><span class="line"></span><br><span class="line">注：后面的用户名根据实际情况填写，只要确保唯一性即可，填什么都可。</span><br></pre></td></tr></table></figure><p>3.终端显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\usr\bin&gt;ssh-keygen -trsa -C &quot;maojing&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):</span><br><span class="line">Created directory &apos;/c/Users/Administrator/.ssh&apos;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:NjSd5gVOH+iPNlfqV7eHtp9350ismT7oxEP2eEyEQJY maojing</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|       .+.o..    |</span><br><span class="line">|       .E=.= .   |</span><br><span class="line">|        o.* +    |</span><br><span class="line">|       . +.o  .  |</span><br><span class="line">|        S +o.o   |</span><br><span class="line">|       . =+=+.  o|</span><br><span class="line">|         .==+ ooo|</span><br><span class="line">|         ..oo=+o*|</span><br><span class="line">|         ...=+o=B|</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">C:\Program Files\Git\usr\bin&gt;</span><br></pre></td></tr></table></figure><p>4.获取公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub.</span><br><span class="line"></span><br><span class="line">根据这句话即可找到公钥</span><br></pre></td></tr></table></figure><p>5.gitlab后台添加公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击用户-设置-SSH密钥，将上面复制的密钥粘贴进对应的位置，点击add key即可。</span><br></pre></td></tr></table></figure><p>6.ssh免密拉取远端代码到本地代码仓库</p><p>剩余操作详见《gitLab http 操作》一文</p>]]></content>
    
    <summary type="html">
    
      SSH-Win10使用SSH免密拉取GitLab代码
    
    </summary>
    
      <category term="SSH" scheme="http://yoursite.com/categories/SSH/"/>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
      <category term="Win 10" scheme="http://yoursite.com/tags/Win-10/"/>
    
      <category term="rsa" scheme="http://yoursite.com/tags/rsa/"/>
    
  </entry>
  
  <entry>
    <title>SSH-访问远程主机</title>
    <link href="http://yoursite.com/2019/01/17/SSH-%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/01/17/SSH-访问远程主机/</id>
    <published>2019-01-17T05:41:35.000Z</published>
    <updated>2019-01-17T06:40:37.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h1><p>如果你是第一次登录对方主机，系统会出现下面的提示：</p><blockquote><p>　　$ ssh root@主机ip</p><p>　　The authenticity of host ‘host (12.18.429.21)’ can’t be established.</p><p>　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</p><p>　　Are you sure you want to continue connecting (yes/no)?</p></blockquote><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p><p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。</p><blockquote><p>　　Are you sure you want to continue connecting (yes/no)? yes</p></blockquote><p>系统会出现一句提示，表示host主机已经得到认可。</p><blockquote><p>　　Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.</p></blockquote><p>然后，会要求输入密码。</p><blockquote><p>　　Password: (enter password)</p></blockquote><p>如果密码正确，就可以登录了。</p><p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h1 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h1><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p><p>如何生成公钥请参考《SSH-Win10使用SSH免密拉取GitLab代码》，成功生成后再继续下面操作。</p><p>这时再输入下面的命令，将公钥传送到远程主机host上面：</p><blockquote><p>　　$ ssh-copy-id root@主机ip</p></blockquote><p>好了，从此你再登录，就不需要输入密码了。</p><p>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p><blockquote><p>　　RSAAuthentication yes<br>　　PubkeyAuthentication yes<br>　　AuthorizedKeysFile .ssh/authorized_keys</p></blockquote><p>然后，重启远程主机的ssh服务。</p><blockquote><p>　　// ubuntu系统<br>　　service ssh restart</p><p>　　// debian系统<br>　　/etc/init.d/ssh restart</p></blockquote>]]></content>
    
    <summary type="html">
    
      ssh口令登陆和公钥登录
    
    </summary>
    
      <category term="SSH" scheme="http://yoursite.com/categories/SSH/"/>
    
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
      <category term="免密登录" scheme="http://yoursite.com/tags/%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>hexo-阿里云</title>
    <link href="http://yoursite.com/2019/01/17/hexo-%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://yoursite.com/2019/01/17/hexo-阿里云/</id>
    <published>2019-01-17T04:51:54.000Z</published>
    <updated>2019-01-21T04:31:33.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>将博客部署在GitHub上，不失为一种省时，省力，省钱的优选方案，但我打心底还是想部署到阿里云上面，主要出于两方面考虑，一是隐私（当然github也可操作）；二是稳定性，毕竟阿里云服可选国内的。</p><a id="more"></a><p>但事实确实验证上面所说的。博客前面整理了阿里云ECS购买，域名备案等流程（整理来自个人笔记），特别是域名备案，算不上复杂，但走流程是需要提供材料，然后你懂的，就是耐心等待！这也是第一次个人实操域名备案（之前只是买买ECS做开发测试用）。</p><p>且先不管域名备案是否通过，我们先了解下如何将博客部署到阿里云上。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>遇到问题不可怕，可怕的是遇到问题后毫无思绪！</p><p>操作思路是这样，在云主机上搭建git仓库，使用nginx作为网页服务器，最终通过git将hexo博客部署到云主机上。</p><p>系统环境:Ubuntu Server 16.04.1 LTS 64位</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-设置SSH登陆"><a href="#1-设置SSH登陆" class="headerlink" title="1.设置SSH登陆"></a>1.设置SSH登陆</h2><p>关于如何生成密钥请参考《SSH-Win10使用SSH免密拉取GitLab代码》。然后再window命令提示符执行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@云主机ip</span><br></pre></td></tr></table></figure><p>将用户的公钥存储到远程主机上，过程会让你输入远程主机的密码（在购买ECS过程中有设置过的）。</p><ul><li><p>原理：用户将公钥储存在远程主机上。登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回给远程主机。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，允许登录，不再要求密码。</p></li><li><p>注意：在window上执行命令时可能抛出” ‘ssh’ 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。“问题，那么请在环境变量中添加如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GIT_HOME:C:\Program Files\Git</span><br><span class="line">然后编辑path新增</span><br><span class="line">%GIT_HOME%\bin</span><br><span class="line">然后在命令提示符输入：</span><br><span class="line">sh</span><br><span class="line">再执行</span><br><span class="line">ssh-copy-id root@云主机ip</span><br><span class="line">将公钥拷贝到远程云主机</span><br></pre></td></tr></table></figure></li><li><p>口令登陆：不用讲公钥拷贝到云主机，直接使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@云主机ip</span><br></pre></td></tr></table></figure><p>然后按照提示输入主机root账户的登陆密码即可。</p></li></ul><h2 id="2-安装Git和nginx"><a href="#2-安装Git和nginx" class="headerlink" title="2.安装Git和nginx"></a>2.安装Git和nginx</h2><p>我这里使用的是Xshell访问云服务器，输入如下密令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install git-core nginx</span><br></pre></td></tr></table></figure><h2 id="3-配置nginx"><a href="#3-配置nginx" class="headerlink" title="3.配置nginx"></a>3.配置nginx</h2><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/www/blog</span><br></pre></td></tr></table></figure><p>进入nginx配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.conf</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /var/www/blog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h2 id="4-Git-Hooks"><a href="#4-Git-Hooks" class="headerlink" title="4.Git Hooks"></a>4.Git Hooks</h2><p>我们要将hexo在本地生成的静态博客同步到远程git仓库。那么先要在远程主机上设置Git仓库，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/blog.git &amp;&amp; cd ~/blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><p>配置Hooks脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/www/blog</span><br><span class="line">git clone /root/blog.git /var/www/blog</span><br></pre></td></tr></table></figure><p>解释：先将原有的blog删除，然后从仓库克隆一份到blog文件下。</p><p>注意：如果上面vim进入post-receive文件中，退出时有问题，则按照路径一步步进入到hooks文件夹下，再执行vim post-receive进入，编辑脚本，再保存退出即可。</p><h2 id="5-修改Hexo配置文件"><a href="#5-修改Hexo配置文件" class="headerlink" title="5.修改Hexo配置文件"></a>5.修改Hexo配置文件</h2><p>修改_config.yml如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: root@云主机ip:blog.git</span><br></pre></td></tr></table></figure><h2 id="6-部署"><a href="#6-部署" class="headerlink" title="6.部署"></a>6.部署</h2><p>依次输入如下密令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>让后打开浏览器输入：http://云主机ip:8080即可访问。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>将hexo部署到阿里云上相比部署到github上，还是复杂些。除了涉及服务器ECS购买，域名购买绑定，域名备案外，另外技术上还涉及SSH，ngnix，git等的使用。但考虑到阿里云具备的开篇所提到的两点好处，一切都值了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;将博客部署在GitHub上，不失为一种省时，省力，省钱的优选方案，但我打心底还是想部署到阿里云上面，主要出于两方面考虑，一是隐私（当然github也可操作）；二是稳定性，毕竟阿里云服可选国内的。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="aliyun" scheme="http://yoursite.com/tags/aliyun/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>阿里云-域名备案</title>
    <link href="http://yoursite.com/2019/01/16/%E9%98%BF%E9%87%8C%E4%BA%91-%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88/"/>
    <id>http://yoursite.com/2019/01/16/阿里云-域名备案/</id>
    <published>2019-01-16T06:24:33.000Z</published>
    <updated>2019-01-16T07:20:11.241Z</updated>
    
    <content type="html"><![CDATA[<p>来来来，大家一起看阿里云官方文档！</p><a id="more"></a><p>详细流程请参考阿里云官方文档：</p><p><a href="https://help.aliyun.com/knowledge_detail/36922.html?spm=a2c4g.11186623.6.558.262422f0zyedbj" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/36922.html?spm=a2c4g.11186623.6.558.262422f0zyedbj</a></p><p>注意：</p><p>1.购买的服务器ECS效期须大于3个月；</p><p>2.初审很快，大概半个小时左右就接到95187电话，简单核实了下身份信息；</p><p>3.在提交材料时，手机上显示的是什么“承诺书”，实质上就是“网站备案系信息真实性核验单”；</p><p>4.网站备案系信息真实性核验单，选择电脑上传资料时，变会看见下载链接，以及填写样例图；</p><p>5.另外教程中有如何获取阿里云幕布的操作（简直贴心）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来来来，大家一起看阿里云官方文档！&lt;/p&gt;
    
    </summary>
    
      <category term="阿里云" scheme="http://yoursite.com/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="域名备案" scheme="http://yoursite.com/tags/%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88/"/>
    
  </entry>
  
</feed>
